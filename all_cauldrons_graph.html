<!DOCTYPE html>
<html>
<head>
<title>All Cauldrons - Potion Levels</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
.container { max-width: 1400px; margin: 0 auto; }
h1 { text-align: center; color: #333; }
.grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 20px; }
.card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
.card h3 { margin: 0 0 10px 0; font-size: 16px; }
.chart-wrapper { position: relative; height: 350px; }
@media (max-width: 1200px) { .grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>
<div class="container">
<h1>All Cauldrons - Potion Level Over Time</h1>
<p style="text-align: center; color: #666;">Oct 31 - Nov 7, 2024</p>
<div id="loading" style="text-align: center; padding: 20px;">Loading data...</div>
<div class="grid" id="graphsGrid" style="display: none;">
</div>
</div>

<script>
let cauldrons = [];
let historicalData = [];
let transportTickets = [];
let unreportedDrains = [];
let charts = {};

async function loadData() {
    try {
        // Load all data files
        const [cauldronsRes, historicalRes, ticketsRes, unreportedRes] = await Promise.all([
            fetch('cauldrons.json'),
            fetch('historical_data.json'),
            fetch('transport_tickets.json'),
            fetch('unreported_drains.json').catch(() => ({ json: () => Promise.resolve({ unreported_drains: [] }) }))
        ]);
        
        const cauldronsData = await cauldronsRes.json();
        const historicalDataObj = await historicalRes.json();
        const ticketsData = await ticketsRes.json();
        const unreportedData = await unreportedRes.json();
        
        cauldrons = cauldronsData.cauldrons;
        historicalData = historicalDataObj.data;
        transportTickets = ticketsData.transport_tickets;
        unreportedDrains = unreportedData.unreported_drains || [];
        
        // Hide loading, show grid
        document.getElementById('loading').style.display = 'none';
        document.getElementById('graphsGrid').style.display = 'grid';
        
        // Create graph for each cauldron
        cauldrons.forEach(cauldron => {
            createCauldronGraph(cauldron);
        });
    } catch (error) {
        console.error('Error loading data:', error);
        document.getElementById('loading').textContent = 'Error loading data. Make sure JSON files are available.';
    }
}

function createCauldronGraph(cauldron) {
    // Create card element
    const card = document.createElement('div');
    card.className = 'card';
    
    const h3 = document.createElement('h3');
    h3.textContent = `${cauldron.name} (${cauldron.id})`;
    card.appendChild(h3);
    
    const chartWrapper = document.createElement('div');
    chartWrapper.className = 'chart-wrapper';
    const canvas = document.createElement('canvas');
    canvas.id = `chart_${cauldron.id}`;
    chartWrapper.appendChild(canvas);
    card.appendChild(chartWrapper);
    
    // Count collections for this cauldron
    const collections = transportTickets.filter(t => t.cauldron_id === cauldron.id);
    const countP = document.createElement('p');
    countP.style.cssText = 'font-size: 11px; color: #666; margin: 5px 0 0 0;';
    countP.textContent = `${collections.length} collections | Max: ${cauldron.max_volume}L`;
    card.appendChild(countP);
    
    document.getElementById('graphsGrid').appendChild(card);
    
    // Extract data (sample every 10 minutes to keep it manageable)
    const timestamps = [];
    const levels = [];
    
    for (let i = 0; i < historicalData.length; i += 10) {
        const entry = historicalData[i];
        const date = new Date(entry.timestamp);
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        timestamps.push(`${month}/${day} ${hours}:${minutes}`);
        levels.push(entry.cauldron_levels[cauldron.id] || 0);
    }
    
    // Find collections for this cauldron
    const cauldronCollections = transportTickets
        .filter(ticket => ticket.cauldron_id === cauldron.id)
        .map(ticket => {
            const startTime = new Date(ticket.collection_start_timestamp);
            const endTime = new Date(ticket.collection_timestamp);
            const durationMs = endTime - startTime;
            const durationMin = Math.round(durationMs / 60000 * 10) / 10;
            
            // Find indices (divide by 10 since we're sampling every 10 minutes)
            const startIdx = Math.floor(
                historicalData.findIndex(e => {
                    const eDate = new Date(e.timestamp);
                    return eDate >= startTime;
                }) / 10
            );
            
            const endIdx = Math.floor(
                historicalData.findIndex(e => {
                    const eDate = new Date(e.timestamp);
                    return eDate >= endTime;
                }) / 10
            );
            
            return {
                ticket_id: ticket.ticket_id,
                start_idx: Math.max(0, startIdx >= 0 ? startIdx : 0),
                end_idx: Math.min(timestamps.length - 1, endIdx >= 0 ? endIdx : timestamps.length - 1),
                amount: ticket.amount_collected,
                duration_min: durationMin,
                is_suspicious: ticket.is_suspicious || false,
                suspicious_type: ticket.suspicious_type || null
            };
        });
    
    // Create annotations
    const maxVol = cauldron.max_volume;
    const annotations = { annotations: {} };
    
    cauldronCollections.forEach((coll, idx) => {
        if (coll.start_idx >= 0 && coll.start_idx < timestamps.length) {
            // Use red color for suspicious tickets, blue for normal
            const isSuspicious = coll.is_suspicious;
            const borderColor = isSuspicious ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 123, 255, 0.8)';
            const bgColor = isSuspicious ? 'rgba(255, 0, 0, 0.9)' : 'rgba(0, 123, 255, 0.9)';
            const boxBgColor = isSuspicious ? 'rgba(255, 0, 0, 0.05)' : 'rgba(0, 123, 255, 0.05)';
            const boxBorderColor = isSuspicious ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 123, 255, 0.3)';
            const endLineColor = isSuspicious ? 'rgba(255, 0, 0, 0.6)' : 'rgba(0, 123, 255, 0.6)';
            
            const warningText = isSuspicious ? ' ⚠️' : '';
            
            annotations.annotations[`line_start_${idx}`] = {
                type: 'line',
                xMin: coll.start_idx,
                xMax: coll.start_idx,
                borderColor: borderColor,
                borderWidth: 2,
                borderDash: [5, 5],
                label: {
                    display: true,
                    content: `#${idx + 1} (${coll.duration_min}m)${warningText}`,
                    position: 'start',
                    backgroundColor: bgColor,
                    color: 'white',
                    font: { size: 10 },
                    padding: 4
                }
            };
            
            if (coll.end_idx < timestamps.length) {
                annotations.annotations[`line_end_${idx}`] = {
                    type: 'line',
                    xMin: coll.end_idx,
                    xMax: coll.end_idx,
                    borderColor: endLineColor,
                    borderWidth: 1.5,
                    borderDash: [3, 3]
                };
            }
        }
    });
    
    // Find unreported drains for this cauldron
    const cauldronUnreportedDrains = unreportedDrains.filter(drain => drain.cauldron_id === cauldron.id);
    cauldronUnreportedDrains.forEach((drain, drainIdx) => {
        const drainStart = new Date(drain.drain_start_timestamp);
        const drainEnd = new Date(drain.drain_end_timestamp);
        
        // Find indices in sampled data (divide by 10 since we sample every 10 minutes)
        let drainStartIdx = historicalData.findIndex(e => {
            const eDate = new Date(e.timestamp);
            return eDate >= drainStart;
        });
        if (drainStartIdx < 0) drainStartIdx = 0;
        drainStartIdx = Math.floor(drainStartIdx / 10);
        
        let drainEndIdx = historicalData.findIndex(e => {
            const eDate = new Date(e.timestamp);
            return eDate >= drainEnd;
        });
        if (drainEndIdx < 0) drainEndIdx = historicalData.length - 1;
        drainEndIdx = Math.floor(drainEndIdx / 10);
        
        if (drainStartIdx >= 0 && drainStartIdx < timestamps.length) {
            const annIdx = cauldronCollections.length + drainIdx;
            const drainColor = 'rgba(255, 165, 0, 0.8)'; // Orange for unreported drains
            const drainBgColor = 'rgba(255, 165, 0, 0.9)';
            const drainBoxColor = 'rgba(255, 165, 0, 0.05)';
            const drainBorderColor = 'rgba(255, 165, 0, 0.3)';
            
            annotations.annotations[`unreported_line_start_${annIdx}`] = {
                type: 'line',
                xMin: drainStartIdx,
                xMax: drainStartIdx,
                borderColor: drainColor,
                borderWidth: 3,
                borderDash: [10, 5],
                label: {
                    display: true,
                    content: `⚠️ NO TICKET`,
                    position: 'start',
                    backgroundColor: drainBgColor,
                    color: 'white',
                    font: { size: 9, weight: 'bold' },
                    padding: 3
                }
            };
            
            if (drainEndIdx < timestamps.length) {
                annotations.annotations[`unreported_line_end_${annIdx}`] = {
                    type: 'line',
                    xMin: drainEndIdx,
                    xMax: drainEndIdx,
                    borderColor: drainColor,
                    borderWidth: 2,
                    borderDash: [10, 5]
                };
            }
        }
    });
    
    // Create chart
    const ctx = canvas.getContext('2d');
    charts[cauldron.id] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: timestamps,
            datasets: [{
                label: 'Level (L)',
                data: levels,
                borderColor: 'rgb(139, 69, 19)',
                backgroundColor: 'rgba(139, 69, 19, 0.1)',
                borderWidth: 1.5,
                tension: 0.1,
                pointRadius: 0,
                fill: true
            }, {
                label: 'Max Capacity',
                data: Array(timestamps.length).fill(maxVol),
                borderColor: 'rgb(255, 0, 0)',
                borderDash: [5, 5],
                borderWidth: 1,
                pointRadius: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true, position: 'top', labels: { font: { size: 10 } } },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            label += context.parsed.y.toFixed(1) + 'L';
                            return label;
                        }
                    }
                },
                annotation: annotations
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: maxVol * 1.1,
                    title: { display: true, text: 'Level (L)', font: { size: 10 } },
                    ticks: { font: { size: 9 } }
                },
                x: {
                    title: { display: true, text: 'Time', font: { size: 10 } },
                    ticks: { font: { size: 8 }, maxRotation: 45, minRotation: 45, maxTicksLimit: 12 }
                }
            }
        }
    });
}

// Load data when page loads
window.addEventListener("DOMContentLoaded", loadData);
</script>
</body>
</html>
