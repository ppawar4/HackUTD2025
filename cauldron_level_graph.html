<!DOCTYPE html>
<html>
<head>
    <title>Cauldron Level Over Time</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        .controls { margin: 20px 0; display: flex; gap: 15px; align-items: center; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-weight: bold; font-size: 14px; }
        select, button { padding: 8px 12px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; }
        button { background-color: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        .collection-info { margin-top: 20px; font-size: 12px; color: #666; }
        #levelChart { max-height: 600px; }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="title">Cauldron Level Over Time</h1>
        <p id="subtitle">Oct 31 - Nov 7, 2024 | All Minute-by-Minute Data</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="cauldronSelect">Cauldron:</label>
                <select id="cauldronSelect"></select>
            </div>
            <div class="control-group">
                <button onclick="updateGraph()">Update Graph</button>
            </div>
        </div>
        
        <div id="loading" style="text-align: center; padding: 20px;">Loading data...</div>
        <canvas id="levelChart" style="display: none;"></canvas>
        <div class="collection-info" id="collectionInfo" style="display: none;"></div>
    </div>
    
    <script>
        let cauldrons = [];
        let historicalData = [];
        let transportTickets = [];
        let currentChart = null;
        
        async function loadData() {
            try {
                // Load all data files
                const [cauldronsRes, historicalRes, ticketsRes, unreportedRes] = await Promise.all([
                    fetch('cauldrons.json'),
                    fetch('historical_data.json'),
                    fetch('transport_tickets.json'),
                    fetch('unreported_drains.json').catch(() => ({ json: () => Promise.resolve({ unreported_drains: [] }) }))
                ]);
                
                const cauldronsData = await cauldronsRes.json();
                const historicalDataObj = await historicalRes.json();
                const ticketsData = await ticketsRes.json();
                const unreportedData = await unreportedRes.json();
                
                cauldrons = cauldronsData.cauldrons;
                historicalData = historicalDataObj.data;
                transportTickets = ticketsData.transport_tickets;
                unreportedDrains = unreportedData.unreported_drains || [];
                
                // Populate cauldron dropdown
                const cauldronSelect = document.getElementById('cauldronSelect');
                cauldrons.forEach(cauldron => {
                    const option = document.createElement('option');
                    option.value = cauldron.id;
                    option.textContent = `${cauldron.id} - ${cauldron.name}`;
                    if (cauldron.id === 'cauldron_001') option.selected = true;
                    cauldronSelect.appendChild(option);
                });
                
                // Hide loading, show canvas
                document.getElementById('loading').style.display = 'none';
                document.getElementById('levelChart').style.display = 'block';
                document.getElementById('collectionInfo').style.display = 'block';
                
                // Load initial graph
                updateGraph();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Make sure JSON files are available.';
            }
        }
        
        function updateGraph() {
            const cauldronId = document.getElementById('cauldronSelect').value;
            const cauldron = cauldrons.find(c => c.id === cauldronId);
            if (!cauldron) return;
            
            // Extract all data for this cauldron (sample every minute, but reduce for display)
            const timestamps = [];
            const levels = [];
            
            // Sample every 10 minutes to keep file size manageable while showing all days
            for (let i = 0; i < historicalData.length; i += 10) {
                const entry = historicalData[i];
                const date = new Date(entry.timestamp);
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                timestamps.push(`${month}/${day} ${hours}:${minutes}`);
                levels.push(entry.cauldron_levels[cauldronId] || 0);
            }
            
            // Find all collections for this cauldron
            const cauldronCollections = transportTickets
                .filter(ticket => ticket.cauldron_id === cauldronId)
                .map(ticket => {
                    const startTime = new Date(ticket.collection_start_timestamp);
                    const endTime = new Date(ticket.collection_timestamp);
                    const durationMs = endTime - startTime;
                    const durationMin = Math.round(durationMs / 60000 * 10) / 10;
                    
                    // Find indices in the sampled data (divide by 10 since we sample every 10 minutes)
                    let startIdx = historicalData.findIndex(e => {
                        const eDate = new Date(e.timestamp);
                        return eDate >= startTime;
                    });
                    if (startIdx < 0) startIdx = 0;
                    startIdx = Math.floor(startIdx / 10);
                    
                    let endIdx = historicalData.findIndex(e => {
                        const eDate = new Date(e.timestamp);
                        return eDate >= endTime;
                    });
                    if (endIdx < 0) endIdx = historicalData.length - 1;
                    endIdx = Math.floor(endIdx / 10);
                    
                    const startDate = startTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const startTimeStr = startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                    
                    return {
                        ticket_id: ticket.ticket_id,
                        start_idx: startIdx,
                        end_idx: Math.min(endIdx, timestamps.length - 1),
                        amount: ticket.amount_collected,
                        start_time: `${startDate} ${startTimeStr}`,
                        duration_min: durationMin,
                        is_suspicious: ticket.is_suspicious || false,
                        suspicious_type: ticket.suspicious_type || null
                    };
                });
            
            // Find unreported drains for this cauldron
            const cauldronUnreportedDrains = unreportedDrains.filter(drain => drain.cauldron_id === cauldronId);
            
            // Update title
            document.getElementById('title').textContent = `${cauldron.name} - Potion Level Over Time`;
            document.getElementById('collectionInfo').innerHTML = `
                <p><strong>Collections:</strong> ${cauldronCollections.length} hauls during this period</p>
                <p>Blue vertical lines indicate collection start times. Gray shaded areas show collection duration.</p>
            `;
            
            // Create annotations
            const maxVol = cauldron.max_volume;
            const annotations = { annotations: {} };
            
            cauldronCollections.forEach((coll, idx) => {
                if (coll.start_idx >= 0 && coll.start_idx < timestamps.length) {
                    // Use red color for suspicious tickets, blue for normal
                    const isSuspicious = coll.is_suspicious;
                    const borderColor = isSuspicious ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 123, 255, 0.8)';
                    const bgColor = isSuspicious ? 'rgba(255, 0, 0, 0.9)' : 'rgba(0, 123, 255, 0.9)';
                    const boxBgColor = isSuspicious ? 'rgba(255, 0, 0, 0.05)' : 'rgba(0, 123, 255, 0.05)';
                    const boxBorderColor = isSuspicious ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 123, 255, 0.3)';
                    const endLineColor = isSuspicious ? 'rgba(255, 0, 0, 0.6)' : 'rgba(0, 123, 255, 0.6)';
                    
                    const warningText = isSuspicious ? ' ⚠️' : '';
                    
                    annotations.annotations[`line_start_${idx}`] = {
                        type: 'line',
                        xMin: coll.start_idx,
                        xMax: coll.start_idx,
                        borderColor: borderColor,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: `#${idx + 1} (${coll.duration_min}m)${warningText}`,
                            position: 'start',
                            backgroundColor: bgColor,
                            color: 'white',
                            font: { size: 10 },
                            padding: 4
                        }
                    };
                    
                    if (coll.end_idx < timestamps.length) {
                        annotations.annotations[`line_end_${idx}`] = {
                            type: 'line',
                            xMin: coll.end_idx,
                            xMax: coll.end_idx,
                            borderColor: endLineColor,
                            borderWidth: 1.5,
                            borderDash: [3, 3]
                        };
                    }
                }
            });
            
            // Add annotations for unreported drains (no ticket, but level drops)
            cauldronUnreportedDrains.forEach((drain, drainIdx) => {
                const drainStart = new Date(drain.drain_start_timestamp);
                const drainEnd = new Date(drain.drain_end_timestamp);
                
                // Find indices in sampled data (divide by 10 since we sample every 10 minutes)
                let drainStartIdx = historicalData.findIndex(e => {
                    const eDate = new Date(e.timestamp);
                    return eDate >= drainStart;
                });
                if (drainStartIdx < 0) drainStartIdx = 0;
                drainStartIdx = Math.floor(drainStartIdx / 10);
                
                let drainEndIdx = historicalData.findIndex(e => {
                    const eDate = new Date(e.timestamp);
                    return eDate >= drainEnd;
                });
                if (drainEndIdx < 0) drainEndIdx = historicalData.length - 1;
                drainEndIdx = Math.floor(drainEndIdx / 10);
                
                if (drainStartIdx >= 0 && drainStartIdx < timestamps.length) {
                    const annIdx = cauldronCollections.length + drainIdx;
                    const drainColor = 'rgba(255, 165, 0, 0.8)'; // Orange for unreported drains
                    const drainBgColor = 'rgba(255, 165, 0, 0.9)';
                    const drainBoxColor = 'rgba(255, 165, 0, 0.05)';
                    const drainBorderColor = 'rgba(255, 165, 0, 0.5)';
                    
                    annotations.annotations[`unreported_line_start_${annIdx}`] = {
                        type: 'line',
                        xMin: drainStartIdx,
                        xMax: drainStartIdx,
                        borderColor: drainColor,
                        borderWidth: 3,
                        borderDash: [10, 5],
                        label: {
                            display: true,
                            content: `⚠️ NO TICKET - ~${drain.estimated_amount_drained_liters}L`,
                            position: 'start',
                            backgroundColor: drainBgColor,
                            color: 'white',
                            font: { size: 10, weight: 'bold' },
                            padding: 4
                        }
                    };
                    
                    if (drainEndIdx < timestamps.length) {
                        annotations.annotations[`unreported_line_end_${annIdx}`] = {
                            type: 'line',
                            xMin: drainEndIdx,
                            xMax: drainEndIdx,
                            borderColor: drainColor,
                            borderWidth: 2,
                            borderDash: [10, 5]
                        };
                    }
                }
            });
            
            // Create or update chart
            const ctx = document.getElementById('levelChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (currentChart) {
                currentChart.destroy();
            }
            
            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [{
                        label: 'Level (L)',
                        data: levels,
                        borderColor: 'rgb(139, 69, 19)',
                        backgroundColor: 'rgba(139, 69, 19, 0.1)',
                        borderWidth: 2.5,
                        tension: 0.1,
                        pointRadius: 0,
                        fill: true
                    }, {
                        label: 'Max Capacity',
                        data: Array(timestamps.length).fill(maxVol),
                        borderColor: 'rgb(255, 0, 0)',
                        borderDash: [5, 5],
                        borderWidth: 1.5,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    label += context.parsed.y.toFixed(1) + 'L';
                                    return label;
                                }
                            }
                        },
                        annotation: annotations
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: maxVol * 1.1,
                            title: { display: true, text: 'Potion Level (L)' },
                            ticks: { font: { size: 10 } }
                        },
                        x: {
                            title: { display: true, text: 'Date & Time' },
                            ticks: { font: { size: 9 }, maxRotation: 45, minRotation: 45, maxTicksLimit: 20 }
                        }
                    }
                }
            });
        }
        
        // Load data when page loads
        window.addEventListener("DOMContentLoaded", loadData);
    </script>
</body>
</html>
